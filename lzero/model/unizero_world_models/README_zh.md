## UniZero 世界模型中的位置编码

本节详细介绍了 UniZero 世界模型中所采用的位置编码策略，并就两种可配置选项进行了说明，其选择依据为配置参数 `self.config.rotary_emb` 的取值情况。

> **配置选项：**
> - 当 `self.config.rotary_emb = False` 时，采用 **绝对位置编码** （基于 `nn.Embedding`）。
> - 当 `self.config.rotary_emb = True` 时，采用 **相对位置编码** （基于 ROPE）。

---

### 1. 绝对位置编码（基于 `nn.Embedding`）

当配置参数 `self.config.rotary_emb` 为 **False** 时，模型使用 `nn.Embedding` 进行位置编码，其实现流程包括以下步骤：

#### 1.1 Embedding 层初始化

- **初始化：**  
  利用 `nn.Embedding` 初始化位置嵌入层，将序列中每个位置索引映射为固定尺寸的嵌入向量。

#### 1.2 上下文长度的限制

- **kv_cache 管理：**  
  由于受限于上下文长度（`context_length`），模型在缓存键值对（kv_cache）时只保留最近的 `<context_length>` 步，以保证计算效率与内存消耗处于可控范围内。

#### 1.3 位置嵌入的矫正

在复用 kv_cache 时，直接使用历史位置向量会带来索引重复或错误问题，从而引发模型对序列位置信息的混淆。为解决这一问题，引入位置嵌入矫正机制。

- **问题描述：**  
  假设推理过程中总步数计算为 `5 * 2 = 10`，则初始 kv_cache 的位置索引为：  
  `0, 1, 2, 3, 4, 5, 6, 7, 8, 9`  
  
  当新的数据到来时，需移除 kv_cache 的前 2 步，此时剩余索引为：  
  `2, 3, 4, 5, 6, 7, 8, 9`  
  
  若直接拼接，可能导致索引重复或错误，例如：  
  `2, 3, 4, 5, 6, 7, 8, 9, 8, 9`

- **矫正方案：**  
  为避免上述问题，模型会对 kv_cache 中的位置索引进行重置，将其重新标定为连续的序列，例如：  
  `0, 1, 2, 3, 4, 5, 6, 7`

该机制有效地模拟了相对位置编码的效果，从而确保位置嵌入在复用过程中不会累积误差。

---

### 2. 相对位置编码（基于 ROPE）

当配置参数 `self.config.rotary_emb` 为 **True** 时，模型采用 ROPE（Rotary Position Embedding）进行位置编码。ROPE 的主要特点和实现流程如下：

#### 2.1 ROPE 初始化

- **预计算频率成分：**  
  使用提前计算出的频率成分，对查询（Query）和键（Key）的张量施加旋转位置嵌入，将位置信息直接融入自注意力计算中。

#### 2.2 基于剧集时间步的索引方式

- **索引方式：**  
  每个位置的索引基于剧集（episode）的时间步进行分配。  
  例如，在状态 (`s`) 和动作 (`a`) 交替出现的情况下，每个时间步占用两个位置索引。  
  假设一局游戏总共 50 步，其状态和动作依次为：  
  `(s₁, a₁, s₂, a₂, ..., s₅₀, a₅₀)`  
  
  则对应的位置索引为：  
  `1, 2, 3, 4, ..., 99, 100`

#### 2.3 ROPE 的原理

- **理论依据：**  
  ROPE 的设计灵感来源于论文 [RoFormer: Enhanced Transformer with Rotary Position Embedding](https://arxiv.org/abs/2104.09864)。  
  该方法不仅通过旋转矩阵对绝对位置进行了编码，还在自注意力计算中直接融入了相对位置信息，从而实现了：
  - 更高的灵活性（序列长度可以灵活调整）；
  - 随着相对距离增加而逐渐衰减的 inter-token 依赖；
  - 能够兼容线性自注意力结构的相对位置编码。

### 3. 实际表现

在依赖关系较短的环境（如 Pong、DMC Cartpole-Swingup）中，绝对位置编码和 ROPE 的表现较为相似。  
但在依赖关系更长的场景中，ROPE 展现出更高的灵活性和扩展性，更适合处理复杂环境中的长距离依赖问题。

